# #X가 3으로 나누어 떨어지면, 3으로 나눈다.
# X가 2로 나누어 떨어지면, 2로 나눈다.
# 1을 뺀다.
# 연산에 우선순위를 두는것은 소용이없다. 애초에 구현도 못함
# 10을 3으로 나눌때 최소 횟수 = (9가 1이 되는 최소 횟수) + 1 (10에서 1을 빼 9로 갈 때 횟수) dp[N] = dp[N//3] + 1
# 10을 2로 나눌때 최소 횟수 =(5가 1이 되는 최소 횟수) + 1 (10을 2로 나눠 5로 만든 횟수) dp[N] = dp[N//2] + 1
# 10을 1뺄때 최소 횟수 = dp[N] = dp[N-1] + 1 
# 점화식 : dp[N] = min(dp[N-1], dp[N//2] , dp[N//3]) + 1

N = int(input())
dp_list = [0 for _ in range(N+1)] # 어디 쪽에서 +1이 됐는지를 볼수있게 0으로 배열을 초기화한다.

for i in range(2,N+1): # 0과 1은 어차피 답이 0 이기때문에 2부터 시작한다.

  dp_list[i] = dp_list[i-1] + 1 # 1을 먼저 뺴주는 규칙을 찾을수가없기에 1을 먼저 빼주고 시작한다.

  if i % 3 == 0 and dp_list[i // 3] + 1 < dp_list[i]: # 3으로 나눌때 횟수가 1을뺄때 횟수보다 작은지
    dp_list[i] = dp_list[i // 3] + 1 # 작다면 3으로 나눈 횟수 +1 추가
  
  elif i % 2 == 0 and dp_list[i // 2] + 1 < dp_list[i]: # 2로 나눌때 횟수가 1을뺄때 횟수보다 작은디
    dp_list[i] = dp_list[i // 2] + 1 # 작다면 2로나눈횟수 +1 추가

print(dp_list[N]) # 가장 마지막에 남은애가 제일 작은 애임